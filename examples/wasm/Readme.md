# wasm
This directory contains some examples of Lambdas where the actual processing is implemented by applications written in Rust then compiled to [WebAssembly (WASM)](https://webassembly.org/), more precisely [WebAssembly System Interface (WASI)](https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/) using the Rust [wasm32-wasi](https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-intro.md) compiler target.

The `.wasm` WebAssembly bytecode generated by compiling the Rust application is itself Ahead of Time (AOT) compiled for  performance then executed from a Node.js based Lambda using the [WasmEdge](https://wasmedge.org/) WebAssembly runtime.

The fact that the Lambda is built using Node.js in these examples isn't *especially* significant and just reflects how the the original examples behave. In practice in these examples the WasmEdge runtime is run as a child process with the Lambda request body passed to WasmEdge stdin and the processed image returned on WasmEdge stdout, captured by the Lambda and returned.

## Why WebAssembly?
### Safety and Security
WebAssembly describes a memory-safe, sandboxed [execution environment](https://webassembly.github.io/spec/core/exec/index.html#linear-memory) that may even be implemented inside existing JavaScript virtual machines. When [embedded in the web](https://webassembly.org/docs/web/), WebAssembly will enforce the same-origin and permissions security policies of the browser.

The [WebAssembly Security Model](https://webassembly.org/docs/security/) has two important goals: 1. protect users from buggy or malicious modules, and 2. provide developers with useful primitives and mitigations for developing safe applications, within the constraints of 1.

Each WebAssembly module executes within a sandboxed environment separated from the host runtime using [Software Fault Isolation](https://www.thestrangeloop.com/2018/isolation-without-containers.html) techniques. This implies:

* Applications execute independently, and canâ€™t escape the sandbox without going through appropriate APIs.
* Applications generally execute deterministically with limited exceptions.

Additionally, each module is subject to the security policies of its embedding. Within a web browser, this includes restrictions on information flow through same-origin policy. On a non-web platform, this could include the POSIX security model.

Rust applications compiled to WebAssembly further benefit from Rust's own security model, which provides high levels of memory and concurrency safety enforced at compile time by its borrow checker. The [borrow checker](https://blog.logrocket.com/introducing-the-rust-borrow-checker/) is responsible for ensuring that Rust code is memory-safe and has no data races.

### Performance and Efficiency
The Wasm [stack machine](https://webassembly.github.io/spec/core/exec/index.html) is designed to be encoded in a size- and load-time-efficient [binary format](https://webassembly.github.io/spec/core/binary/index.html). WebAssembly aims to execute at native speed by taking advantage of [common hardware capabilities](https://webassembly.org/docs/portability/#assumptions-for-efficient-execution) available on a wide range of platforms.

## Examples
* [image-greyscale](image-greyscale): This Lambda implements a filter (written in Rust and compiled to WebAssembly) to convert images to greyscale based on the [WasmEdge](https://wasmedge.org) image processing [example](https://wasmedge.org/book/en/use_cases/frameworks/serverless/aws.html#example-1-image-processing),

* [image-classification](image-classification): This Lambda classifies images in an application (written in Rust and compiled to WebAssembly) using [WasmEdge Tensorflow](https://github.com/second-state/WasmEdge-tensorflow-tools) to run AI inference based on the [WasmEdge](https://wasmedge.org) inference [example](https://wasmedge.org/book/en/use_cases/frameworks/serverless/aws.html#example-2-ai-inference).
